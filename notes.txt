AHB seems to be largely overkill, most features not required.
No pipelining, protection, split/retry, arbitration etc...

APB seems closer to what we need. No consumption when no transfer.
Maybe wait states required probably no slverr needed

Bus decoder + arbiter ?
One APB master slave per TDM.

Alternatively 
  - 1 single APB master and slave per Sinks
  - 1 single APB master and slave per Sources

Add a counter block which counts a programmable window using pclk.
How many cycles were there no psels active during the window.
Status congestion register. Makes it easy to use minimum bus clock frequency.

Registers should be part of this block add apb master to i2c block.

    sink0.dest_addr          source0.source_addr
    sink1.dest_addr          source0.source_addr
    sink2.dest_addr          source0.source_addr
      :   :   :                :   :   :
    sinkn.dest_addr          source0.source_addr

    congestion monitor enable
    congestion status ( active cycles / window size )

Gray encoding or similar to reduce bus toggling??

=======================
Issues:
------
 - Seems to be sending the last data twice!
   due to current idx changing at same time as ACCESS to SETUP transition
 - source valids out not correct
 
 - Aside: does it make any sense to make the headset current sense 2channel decimator
          available to anyone else??

 - Need to create separate bus with CF master to access control regs
   Or add arbiter on existing bus

=======================

Cost of APB state machine:
-------------------------
APB master: 2 registers for state machine, optional 2 registers to drive outputs
APB slave: 4 and gates
Rising edge detect for each sink valid (64)
  Additional register to deassert the valid (64)

7bit destination address for each sink (32x16 bit registers)
broadcast bit per source (69bits => 5x16bit register)
  map_tdm1_sink01.sink0_dest_addr[5:0]
  map_tdm1_sink01.sink1_dest_addr[5:0]
  map_tdm1_sink23.sink2_dest_addr[5:0]
  map_tdm1_sink23.sink3_dest_addr[5:0]
     :   :   :
  brdcst_subscription_0.tdm1_source0
  brdcst_subscription_0.tdm1_source1
     :   :   :
  
We would need an arbiter in the case of multi master.

Logic to select current master valid/data from master data/valids array 
Logic to generate current slave valid array from paddr

2 clock cycles per transfer. 
Clock is gated when no transfers.
clock frequency should be reduced according to scenario.

Optional congestion counter (need to count to 12500 : 8khz with 100MHz clock worst case)
14 bit window counter, 1 enable bit (1 16bit register)
14 bit status register (1 16bit register)

Reduce significantly number of data buses to 1

current audio mux: (23 registers)
------------------
AUDIO_SINK_EN
AUDIO_SOURCE_EN
AUDIO_SINK_INT_SEL_0
AUDIO_SINK_INT_SEL_1
AUDIO_SOURCE_INT_SEL_0
AUDIO_SOURCE_INT_SEL_1
AUDIO_SINK_SLOT_0
AUDIO_SINK_SLOT_1
AUDIO_SINK_SLOT_2
AUDIO_SINK_SLOT_3
AUDIO_SOURCE_SLOT_0
AUDIO_SOURCE_SLOT_1
AUDIO_SOURCE_SLOT_2
AUDIO_SOURCE_SLOT_3
AUDIO_ASRC_BYPASS
AUDIO_ASRC_SRC
AUDIO_SOURCE_SEL_1
AUDIO_SOURCE_SEL_2
AUDIO_DSP_IN_EN ?? needed ??
HWDEC_BYPASS
HWDEC_SRC       ** need to keep this one
TX_CTRL1.CHANNEL_MUX_SEL[6:3]
AUDIO_ANA_EN
AUDIO_ANA_SEL

Currently using 226 of a maximum of 256 addresses
You need to add the headset current sense decimator output as another sink

========================
Synthesis
---------

use cadence RC
> rc -gui

.tcl - tcl constraints file?
.tcf - transition change format similar to saif for power estimation
